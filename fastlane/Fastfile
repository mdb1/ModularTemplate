default_platform(:ios)

platform :ios do
  desc "Run tests for all packages"
  lane :test_all_packages do
    # Find all package directories
    core_packages = Dir.glob("../Packages/CoreLayer/*").select { |f| File.directory?(f) }
    domain_packages = Dir.glob("../Packages/DomainLayer/*").select { |f| File.directory?(f) }
    presentation_packages = Dir.glob("../Packages/PresentationLayer/*").select { |f| File.directory?(f) }
    
    all_packages = core_packages + domain_packages + presentation_packages
    
    # Track test results
    results = {
      passed: [],
      failed: [],
      skipped: []
    }
    
    # Create the output directory at the project root level
    project_root = File.expand_path("../..", __FILE__)
    FileUtils.mkdir_p(File.join(project_root, "test_output"))
    
    # Track total test counts
    total_tests_run = 0
    total_tests_passed = 0
    total_tests_failed = 0
    
    # Run tests for each package
    all_packages.each do |package_dir|
      package_name = File.basename(package_dir)
      UI.message("Running tests for package: #{package_name}")
      
      begin
        # Test the package directly with xcodebuild
        Dir.chdir(package_dir) do
          # Check if Package.swift exists
          unless File.exist?("Package.swift")
            UI.message("Skipping #{package_name} - no Package.swift found")
            results[:skipped] << { name: package_name, reason: "No Package.swift found" }
            next
          end
          
          # Check if the package has tests
          has_tests = Dir.exist?("Tests") || Dir.glob("Sources/*/Tests").any? || Dir.glob("*/Tests").any?
          unless has_tests
            UI.message("Skipping #{package_name} - no tests found")
            results[:skipped] << { name: package_name, reason: "No tests found" }
            next
          end
          
          # Define result bundle path at the project root level
          result_bundle_path = File.join(project_root, "test_output", "#{package_name}.xcresult")
          
          # Remove any existing result bundle
          FileUtils.rm_rf(result_bundle_path) if File.exist?(result_bundle_path)
          
          # Create a temporary file to capture test output
          output_file = Tempfile.new(["#{package_name}-test", ".log"])
          
          # Run tests using xcodebuild with SPM integration and pipe through xcpretty
          destination = "platform=iOS Simulator,name=iPhone 16 Pro,OS=latest"
          test_command = "set -o pipefail && xcodebuild test -scheme #{package_name} -destination '#{destination}' -resultBundlePath '#{result_bundle_path}' | tee #{output_file.path} | xcpretty --color --report junit"
          
          sh(test_command)
          
          # Read the output file to estimate test counts
          output_content = File.read(output_file.path)
          
          # Parse the output to get test counts
          # Look for patterns like "Executed 5 tests, with 0 failures"
          test_count_match = output_content.match(/Executed (\d+) tests?, with (\d+) failures/)
          
          tests_count = 0
          tests_failed = 0
          
          if test_count_match
            tests_count = test_count_match[1].to_i
            tests_failed = test_count_match[2].to_i
          else
            # If we can't find the pattern, assume at least 1 test passed
            tests_count = 1
            tests_failed = 0
          end
          
          tests_passed = tests_count - tests_failed
          
          # Update total counts
          total_tests_run += tests_count
          total_tests_passed += tests_passed
          total_tests_failed += tests_failed
          
          # Clean up the temporary file
          output_file.close
          output_file.unlink
          
          # Clean up build folder
          FileUtils.rm_rf("build") if Dir.exist?("build")
          
          results[:passed] << { 
            name: package_name, 
            tests_count: tests_count,
            tests_passed: tests_passed,
            tests_failed: tests_failed
          }
        end
      rescue => e
        UI.error("Tests failed for package: #{package_name}")
        UI.error(e.message)
        
        # Try to extract test counts from the error message or assume at least 1 failed test
        tests_failed = 1
        tests_count = 1
        
        # Update total counts
        total_tests_run += tests_count
        total_tests_failed += tests_failed
        
        # Clean up build folder in the package directory
        Dir.chdir(package_dir) do
          FileUtils.rm_rf("build") if Dir.exist?("build")
        end
        
        results[:failed] << { 
          name: package_name, 
          error: e.message,
          tests_count: tests_count,
          tests_failed: tests_failed
        }
      end
    end
    
    # Print a pretty summary
    UI.header("ðŸ“Š Test Results Summary")
    
    # Only show passed section if there are passed tests
    if !results[:passed].empty?
      UI.success("âœ… Passed (#{results[:passed].count} packages, #{total_tests_passed} tests):")
      results[:passed].each do |package|
        tests_info = "#{package[:tests_passed]}/#{package[:tests_count]} tests"
        UI.success("  â€¢ #{package[:name]} - #{tests_info}")
      end
    end
    
    # Only show failed section if there are failed tests
    if !results[:failed].empty?
      UI.error("âŒ Failed (#{results[:failed].count} packages, #{total_tests_failed} tests):")
      results[:failed].each do |package|
        tests_info = "#{package[:tests_failed]} failed tests"
        UI.error("  â€¢ #{package[:name]} - #{tests_info}")
      end
    end
    
    # Only show skipped section if there are skipped packages
    if !results[:skipped].empty?
      UI.important("â­ï¸ Skipped (#{results[:skipped].count}):")
      results[:skipped].each do |package|
        UI.important("  â€¢ #{package[:name]} - #{package[:reason]}")
      end
    end
    
    # Final summary
    UI.header("ðŸ“ˆ Overall Statistics")
    UI.message("Total tests: #{total_tests_run}")
    UI.message("Passed: #{total_tests_passed}")
    UI.message("Failed: #{total_tests_failed}")
    
    if results[:failed].empty?
      UI.success("ðŸŽ‰ All tests passed successfully!")
    else
      UI.error("âŒ Some tests failed. Please check the logs for details.")
      UI.user_error!("Tests failed for #{results[:failed].map { |p| p[:name] }.join(', ')}")
    end
  end
  
  desc "Run tests for a specific scheme"
  lane :test_scheme do |options|
    scheme_name = options[:scheme]
    
    unless scheme_name
      UI.user_error!("Please provide a scheme name using the 'scheme' parameter")
    end
    
    # Find the package directory
    package_dir = nil
    
    # Search in all layer directories
    ["CoreLayer", "DomainLayer", "PresentationLayer"].each do |layer|
      potential_dir = "../Packages/#{layer}/#{scheme_name}"
      if Dir.exist?(potential_dir)
        package_dir = potential_dir
        break
      end
    end
    
    unless package_dir
      UI.user_error!("Package '#{scheme_name}' not found in any layer")
    end
    
    # Create the output directory at the project root level
    project_root = File.expand_path("../..", __FILE__)
    FileUtils.mkdir_p(File.join(project_root, "test_output"))
    
    # Test the package directly with xcodebuild
    Dir.chdir(package_dir) do
      # Check if Package.swift exists
      unless File.exist?("Package.swift")
        UI.user_error!("No Package.swift found in #{scheme_name}")
      end
      
      # Check if the package has tests
      has_tests = Dir.exist?("Tests") || Dir.glob("Sources/*/Tests").any? || Dir.glob("*/Tests").any?
      unless has_tests
        UI.user_error!("No tests found for package #{scheme_name}")
      end
      
      # Define result bundle path at the project root level
      result_bundle_path = File.join(project_root, "test_output", "#{scheme_name}.xcresult")
      
      # Remove any existing result bundle
      FileUtils.rm_rf(result_bundle_path) if File.exist?(result_bundle_path)
      
      # Create a temporary file to capture test output
      output_file = Tempfile.new(["#{scheme_name}-test", ".log"])
      
      # Run tests using xcodebuild with SPM integration and pipe through xcpretty
      destination = "platform=iOS Simulator,name=iPhone 16 Pro,OS=latest"
      test_command = "set -o pipefail && xcodebuild test -scheme #{scheme_name} -destination '#{destination}' -resultBundlePath '#{result_bundle_path}' | tee #{output_file.path} | xcpretty --color --report junit"
      
      sh(test_command)
      
      # Read the output file to estimate test counts
      output_content = File.read(output_file.path)
      
      # Parse the output to get test counts
      # Look for patterns like "Executed 5 tests, with 0 failures"
      test_count_match = output_content.match(/Executed (\d+) tests?, with (\d+) failures/)
      
      tests_count = 0
      tests_failed = 0
      
      if test_count_match
        tests_count = test_count_match[1].to_i
        tests_failed = test_count_match[2].to_i
      else
        # If we can't find the pattern, assume at least 1 test passed
        tests_count = 1
        tests_failed = 0
      end
      
      tests_passed = tests_count - tests_failed
      
      # Clean up the temporary file
      output_file.close
      output_file.unlink
      
      # Clean up build folder
      FileUtils.rm_rf("build") if Dir.exist?("build")
      
      UI.success("ðŸŽ‰ Tests for #{scheme_name} completed successfully!")
      UI.success("   âœ… #{tests_passed}/#{tests_count} tests passed")
    end
  end
end
